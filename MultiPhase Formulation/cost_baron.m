function cost = cost_baron(vars,...
                     NumPhases,...
                     NumLocalKnots,...
                     tauStepLength,...                     
                     FFxIdx_init,FFxIdx_end,...
                     FFyIdx_init,FFyIdx_end,...
                     FHxIdx_init,FHxIdx_end,...
                     FHyIdx_init,FHyIdx_end,...
                     SwitchingTimeIdx_init,SwitchingTimeIdx_end)
%COST Quadratic cost function !!!!!May need quadrature as well


%   Extract Force Vectors
FFx_vector = vars(FFxIdx_init:FFxIdx_end - 1);
FFy_vector = vars(FFyIdx_init:FFyIdx_end - 1);
FHx_vector = vars(FHxIdx_init:FHxIdx_end - 1);
FHy_vector = vars(FHyIdx_init:FHyIdx_end - 1);

%   Time Step Vector
SwitchingTimeVector = vars(SwitchingTimeIdx_init:SwitchingTimeIdx_end); %Extract Switching Time Vector
%KnotIdxVector = 0:NumKnots-1; %Knot index vector, the last knot does not account for integration, ignore
SlopeVector = NumPhases.*diff([0;SwitchingTimeVector]);%Slope to 

SlopeVectorIndex = [];
for i = 1:NumPhases
    SlopeVectorIndex = [SlopeVectorIndex,i*ones(1,NumLocalKnots)];
end

SlopeVectorFull = SlopeVector(SlopeVectorIndex);

TimeStep_vector = tauStepLength.*SlopeVectorFull;%repelem(tauStepLength.*SlopeVector,NumLocalKnots) %time step vector in real-time scale

cost = sum(TimeStep_vector.*FFx_vector.^2) +...
       sum(TimeStep_vector.*FFy_vector.^2) +...
       sum(TimeStep_vector.*FHx_vector.^2) +...
       sum(TimeStep_vector.*FHy_vector.^2);
%        + (vars(xIdx_end) - x_end)' * (vars(xIdx_end) - x_end) ...
%        + (vars(xdotIdx_end) - xdot_end)' * (vars(xdotIdx_end) - xdot_end)...
%        + (vars(yIdx_end) - y_end)' * (vars(yIdx_end) - y_end) ...
%        + (vars(ydotIdx_end) - ydot_end)' * (vars(ydotIdx_end) - ydot_end)...
%        + (vars(thetaIdx_end) - theta_end)' * (vars(thetaIdx_end) - theta_end)...
%        + (vars(thetadotIdx_end) - thetadot_end)' * (vars(thetadotIdx_end) - thetadot_end);

end

